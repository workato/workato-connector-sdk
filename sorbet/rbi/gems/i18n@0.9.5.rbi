# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `i18n` gem.
# Please instead update this file by running `bin/tapioca gem i18n`.

# source://i18n//lib/i18n/gettext/po_parser.rb#15
module GetText; end

# source://i18n//lib/i18n/gettext/po_parser.rb#17
class GetText::PoParser < ::Racc::Parser
  # source://i18n//lib/i18n/gettext/po_parser.rb#19
  def _(x); end

  def _reduce_10(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_13(val, _values, result); end
  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_5(val, _values, result); end
  def _reduce_8(val, _values, result); end
  def _reduce_9(val, _values, result); end

  # source://i18n//lib/i18n/gettext/po_parser.rb#323
  def _reduce_none(val, _values, result); end

  def next_token; end
  def on_comment(comment); end
  def on_message(msgid, msgstr); end
  def parse(str, data, ignore_fuzzy = T.unsafe(nil)); end
  def unescape(orig); end
end

# source://i18n//lib/i18n/gettext/po_parser.rb#184
GetText::PoParser::Racc_arg = T.let(T.unsafe(nil), Array)

# source://i18n//lib/i18n/gettext/po_parser.rb#221
GetText::PoParser::Racc_debug_parser = T.let(T.unsafe(nil), TrueClass)

# source://i18n//lib/i18n/gettext/po_parser.rb#200
GetText::PoParser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

# source://i18n//lib/i18n/core_ext/hash.rb#1
class Hash
  include ::Enumerable
end

# deep_merge_hash! by Stefan Rusterholz, see http://www.ruby-forum.com/topic/142809
#
# source://i18n//lib/i18n/core_ext/hash.rb#21
Hash::MERGER = T.let(T.unsafe(nil), Proc)

# Simple Locale tag implementation that computes subtags by simply splitting
# the locale tag at '-' occurences.
#
# source://i18n//lib/i18n/version.rb#1
module I18n
  extend ::I18n::Base

  class << self
    # source://i18n//lib/i18n/backend/cache.rb#62
    def cache_key_digest; end

    # source://i18n//lib/i18n/backend/cache.rb#66
    def cache_key_digest=(key_digest); end

    # source://i18n//lib/i18n/backend/cache.rb#54
    def cache_namespace; end

    # source://i18n//lib/i18n/backend/cache.rb#58
    def cache_namespace=(namespace); end

    # source://i18n//lib/i18n/backend/cache.rb#46
    def cache_store; end

    # source://i18n//lib/i18n/backend/cache.rb#50
    def cache_store=(store); end

    # Returns the current fallbacks implementation. Defaults to +I18n::Locale::Fallbacks+.
    #
    # source://i18n//lib/i18n/backend/fallbacks.rb#15
    def fallbacks; end

    # Sets the current fallbacks implementation. Use this to set a different fallbacks implementation.
    #
    # source://i18n//lib/i18n/backend/fallbacks.rb#20
    def fallbacks=(fallbacks); end

    # Return String or raises MissingInterpolationArgument exception.
    # Missing argument's logic is handled by I18n.config.missing_interpolation_argument_handler.
    #
    # @raise [ReservedInterpolationKey]
    #
    # source://i18n//lib/i18n/interpolate/ruby.rb#14
    def interpolate(string, values); end

    # source://i18n//lib/i18n/interpolate/ruby.rb#20
    def interpolate_hash(string, values); end

    # source://i18n//lib/i18n.rb#19
    def new_double_nested_cache; end

    # @return [Boolean]
    #
    # source://i18n//lib/i18n/backend/cache.rb#70
    def perform_caching?; end
  end
end

# source://i18n//lib/i18n/exceptions.rb#23
class I18n::ArgumentError < ::ArgumentError; end

# source://i18n//lib/i18n/backend.rb#2
module I18n::Backend; end

# source://i18n//lib/i18n/backend/base.rb#7
module I18n::Backend::Base
  include ::I18n::Backend::Transliterator

  # Returns an array of locales for which translations are available
  # ignoring the reserved translation meta data key :i18n.
  #
  # @raise [NotImplementedError]
  #
  # source://i18n//lib/i18n/backend/base.rb#90
  def available_locales; end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/base.rb#64
  def exists?(locale, key); end

  # Accepts a list of paths to translation files. Loads translations from
  # plain Ruby (*.rb) or YAML files (*.yml). See #load_rb and #load_yml
  # for details.
  #
  # source://i18n//lib/i18n/backend/base.rb#13
  def load_translations(*filenames); end

  # Acts the same as +strftime+, but uses a localized version of the
  # format string. Takes a key from the date/time formats translations as
  # a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
  #
  # @raise [ArgumentError]
  #
  # source://i18n//lib/i18n/backend/base.rb#71
  def localize(locale, object, format = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/base.rb#94
  def reload!; end

  # This method receives a locale, a data hash and options for storing translations.
  # Should be implemented
  #
  # @raise [NotImplementedError]
  #
  # source://i18n//lib/i18n/backend/base.rb#20
  def store_translations(locale, data, options = T.unsafe(nil)); end

  # @raise [I18n::ArgumentError]
  #
  # source://i18n//lib/i18n/backend/base.rb#24
  def translate(locale, key, options = T.unsafe(nil)); end

  protected

  # Deep interpolation
  #
  #   deep_interpolate { people: { ann: "Ann is %{ann}", john: "John is %{john}" } },
  #                    ann: 'good', john: 'big'
  #   #=> { people: { ann: "Ann is good", john: "John is big" } }
  #
  # source://i18n//lib/i18n/backend/base.rb#187
  def deep_interpolate(locale, data, values = T.unsafe(nil)); end

  # Evaluates defaults.
  # If given subject is an Array, it walks the array and returns the
  # first translation that can be resolved. Otherwise it tries to resolve
  # the translation directly.
  #
  # source://i18n//lib/i18n/backend/base.rb#112
  def default(locale, object, subject, options = T.unsafe(nil)); end

  # Interpolates values into a given subject.
  #
  #   if the given subject is a string then:
  #   method interpolates "file %{file} opened by %%{user}", :file => 'test.txt', :user => 'Mr. X'
  #   # => "file test.txt opened by %{user}"
  #
  #   if the given subject is an array then:
  #   each element of the array is recursively interpolated (until it finds a string)
  #   method interpolates ["yes, %{user}", ["maybe no, %{user}, "no, %{user}"]], :user => "bartuz"
  #   # => "["yes, bartuz",["maybe no, bartuz", "no, bartuz"]]"
  #
  # source://i18n//lib/i18n/backend/base.rb#171
  def interpolate(locale, subject, values = T.unsafe(nil)); end

  # Loads a single translations file by delegating to #load_rb or
  # #load_yml depending on the file extension and directly merges the
  # data to the existing translations. Raises I18n::UnknownFileType
  # for all other file extensions.
  #
  # @raise [UnknownFileType]
  #
  # source://i18n//lib/i18n/backend/base.rb#210
  def load_file(filename); end

  # Loads a plain Ruby translations file. eval'ing the file must yield
  # a Hash containing translation data with locales as toplevel keys.
  #
  # source://i18n//lib/i18n/backend/base.rb#222
  def load_rb(filename); end

  # Loads a YAML translations file. The data must have locales as
  # toplevel keys.
  #
  # source://i18n//lib/i18n/backend/base.rb#228
  def load_yml(filename); end

  # The method which actually looks up for the translation in the store.
  #
  # @raise [NotImplementedError]
  #
  # source://i18n//lib/i18n/backend/base.rb#100
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/base.rb#249
  def pluralization_key(entry, count); end

  # Picks a translation from a pluralized mnemonic subkey according to English
  # pluralization rules :
  # - It will pick the :one subkey if count is equal to 1.
  # - It will pick the :other subkey otherwise.
  # - It will pick the :zero subkey in the special case where count is
  #   equal to 0 and there is a :zero subkey present. This behaviour is
  #   not standard with regards to the CLDR pluralization rules.
  # Other backends can implement more flexible or complex pluralization rules.
  #
  # @raise [InvalidPluralizationData]
  #
  # source://i18n//lib/i18n/backend/base.rb#153
  def pluralize(locale, entry, count); end

  # Resolves a translation.
  # If the given subject is a Symbol, it will be translated with the
  # given options. If it is a Proc then it will be evaluated. All other
  # subjects will be returned directly.
  #
  # source://i18n//lib/i18n/backend/base.rb#129
  def resolve(locale, object, subject, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/base.rb#104
  def subtrees?; end

  # source://i18n//lib/i18n/backend/base.rb#236
  def translate_localization_format(locale, object, format, options); end
end

# TODO Should the cache be cleared if new translations are stored?
#
# source://i18n//lib/i18n/backend/cache.rb#77
module I18n::Backend::Cache
  # source://i18n//lib/i18n/backend/cache.rb#78
  def translate(locale, key, options = T.unsafe(nil)); end

  protected

  # source://i18n//lib/i18n/backend/cache.rb#91
  def _fetch(cache_key, &block); end

  # source://i18n//lib/i18n/backend/cache.rb#99
  def cache_key(locale, key, options); end

  # source://i18n//lib/i18n/backend/cache.rb#84
  def fetch(cache_key, &block); end

  private

  # source://i18n//lib/i18n/backend/cache.rb#109
  def digest_item(key); end
end

# In Ruby < 1.9 the following is true: { :foo => 1, :bar => 2 }.hash == { :foo => 2, :bar => 1 }.hash
# Therefore we must use the hash of the inspect string instead to avoid cache key colisions.
#
# source://i18n//lib/i18n/backend/cache.rb#107
I18n::Backend::Cache::USE_INSPECT_HASH = T.let(T.unsafe(nil), FalseClass)

# source://i18n//lib/i18n/backend/cascade.rb#33
module I18n::Backend::Cascade
  # source://i18n//lib/i18n/backend/cascade.rb#34
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end
end

# Backend that chains multiple other backends and checks each of them when
# a translation needs to be looked up. This is useful when you want to use
# standard translations with a Simple backend but store custom application
# translations in a database or other backends.
#
# To use the Chain backend instantiate it and set it to the I18n module.
# You can add chained backends through the initializer or backends
# accessor:
#
#   # preserves the existing Simple backend set to I18n.backend
#   I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
#
# The implementation assumes that all backends added to the Chain implement
# a lookup method with the same API as Simple backend does.
#
# source://i18n//lib/i18n/backend/chain.rb#17
class I18n::Backend::Chain
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base
  include ::I18n::Backend::Chain::Implementation
end

# source://i18n//lib/i18n/backend/chain.rb#18
module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base

  # source://i18n//lib/i18n/backend/chain.rb#23
  def initialize(*backends); end

  # source://i18n//lib/i18n/backend/chain.rb#35
  def available_locales; end

  # Returns the value of attribute backends.
  #
  # source://i18n//lib/i18n/backend/chain.rb#21
  def backends; end

  # Sets the attribute backends
  #
  # @param value the value to set the attribute backends to.
  #
  # source://i18n//lib/i18n/backend/chain.rb#21
  def backends=(_arg0); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/chain.rb#59
  def exists?(locale, key); end

  # source://i18n//lib/i18n/backend/chain.rb#65
  def localize(locale, object, format = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/chain.rb#27
  def reload!; end

  # source://i18n//lib/i18n/backend/chain.rb#31
  def store_translations(locale, data, options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/chain.rb#39
  def translate(locale, key, default_options = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/chain.rb#75
  def namespace_lookup?(result, options); end

  private

  # This is approximately what gets used in ActiveSupport.
  # However since we are not guaranteed to run in an ActiveSupport context
  # it is wise to have our own copy. We underscore it
  # to not pollute the namespace of the including class.
  #
  # source://i18n//lib/i18n/backend/chain.rb#84
  def _deep_merge(hash, other_hash); end
end

# source://i18n//lib/i18n/backend/fallbacks.rb#26
module I18n::Backend::Fallbacks
  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/fallbacks.rb#73
  def exists?(locale, key); end

  # source://i18n//lib/i18n/backend/fallbacks.rb#64
  def extract_non_symbol_default!(options); end

  # Overwrites the Base backend translate method so that it will try each
  # locale given by I18n.fallbacks for the given locale. E.g. for the
  # locale :"de-DE" it might try the locales :"de-DE", :de and :en
  # (depends on the fallbacks implementation) until it finds a result with
  # the given options. If it does not find any result for any of the
  # locales it will then throw MissingTranslation as usual.
  #
  # The default option takes precedence over fallback locales only when
  # it's a Symbol. When the default contains a String, Proc or Hash
  # it is evaluated last after all the fallback locales have been tried.
  #
  # source://i18n//lib/i18n/backend/fallbacks.rb#37
  def translate(locale, key, options = T.unsafe(nil)); end
end

# This module contains several helpers to assist flattening translations.
# You may want to flatten translations for:
#
#   1) speed up lookups, as in the Memoize backend;
#   2) In case you want to store translations in a data store, as in ActiveRecord backend;
#
# You can check both backends above for some examples.
# This module also keeps all links in a hash so they can be properly resolved when flattened.
#
# source://i18n//lib/i18n/backend/flatten.rb#11
module I18n::Backend::Flatten
  # Flatten keys for nested Hashes by chaining up keys:
  #
  #   >> { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}.wind
  #   => { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" }
  #
  # source://i18n//lib/i18n/backend/flatten.rb#54
  def flatten_keys(hash, escape, prev_key = T.unsafe(nil), &block); end

  # Receives a hash of translations (where the key is a locale and
  # the value is another hash) and return a hash with all
  # translations flattened.
  #
  # Nested hashes are included in the flattened hash just if subtree
  # is true and Symbols are automatically stored as links.
  #
  # source://i18n//lib/i18n/backend/flatten.rb#69
  def flatten_translations(locale, data, escape, subtree); end

  # Store flattened links.
  #
  # source://i18n//lib/i18n/backend/flatten.rb#45
  def links; end

  # Shortcut to I18n::Backend::Flatten.normalize_flat_keys
  # and then resolve_links.
  #
  # source://i18n//lib/i18n/backend/flatten.rb#39
  def normalize_flat_keys(locale, key, scope, separator); end

  protected

  # source://i18n//lib/i18n/backend/flatten.rb#107
  def escape_default_separator(key); end

  # source://i18n//lib/i18n/backend/flatten.rb#101
  def find_link(locale, key); end

  # source://i18n//lib/i18n/backend/flatten.rb#88
  def resolve_link(locale, key); end

  # source://i18n//lib/i18n/backend/flatten.rb#84
  def store_link(locale, key, link); end

  class << self
    # Receives a string and escape the default separator.
    #
    # source://i18n//lib/i18n/backend/flatten.rb#33
    def escape_default_separator(key); end

    # normalize_keys the flatten way. This method is significantly faster
    # and creates way less objects than the one at I18n.normalize_keys.
    # It also handles escaping the translation keys.
    #
    # source://i18n//lib/i18n/backend/flatten.rb#18
    def normalize_flat_keys(locale, key, scope, separator); end
  end
end

# source://i18n//lib/i18n/backend/flatten.rb#13
I18n::Backend::Flatten::FLATTEN_SEPARATOR = T.let(T.unsafe(nil), String)

# source://i18n//lib/i18n/backend/flatten.rb#12
I18n::Backend::Flatten::SEPARATOR_ESCAPE_CHAR = T.let(T.unsafe(nil), String)

# Experimental support for using Gettext po files to store translations.
#
# To use this you can simply include the module to the Simple backend - or
# whatever other backend you are using.
#
#  I18n::Backend::Simple.include(I18n::Backend::Gettext)
#
# Now you should be able to include your Gettext translation (*.po) files to
# the +I18n.load_path+ so they're loaded to the backend and you can use them as
# usual:
#
#  I18n.load_path += Dir["path/to/locales/*.po"]
#
# Following the Gettext convention this implementation expects that your
# translation files are named by their locales. E.g. the file en.po would
# contain the translations for the English locale.
#
# To translate text <b>you must use</b> one of the translate methods provided by
# I18n::Gettext::Helpers.
#
#  include I18n::Gettext::Helpers
#  puts _("some string")
#
# Without it strings containing periods (".") will not be translated.
#
# source://i18n//lib/i18n/backend/gettext.rb#31
module I18n::Backend::Gettext
  protected

  # source://i18n//lib/i18n/backend/gettext.rb#39
  def load_po(filename); end

  # source://i18n//lib/i18n/backend/gettext.rb#49
  def normalize(locale, data); end

  # source://i18n//lib/i18n/backend/gettext.rb#66
  def normalize_pluralization(locale, key, value); end

  # source://i18n//lib/i18n/backend/gettext.rb#45
  def parse(filename); end
end

# source://i18n//lib/i18n/backend/gettext.rb#32
class I18n::Backend::Gettext::PoData < ::Hash
  # source://i18n//lib/i18n/backend/gettext.rb#33
  def set_comment(msgid_or_sym, comment); end
end

# source://i18n//lib/i18n/backend/interpolation_compiler.rb#18
module I18n::Backend::InterpolationCompiler
  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#97
  def interpolate(locale, string, values); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#107
  def store_translations(locale, data, options = T.unsafe(nil)); end

  protected

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#113
  def compile_all_strings_in(data); end
end

# source://i18n//lib/i18n/backend/interpolation_compiler.rb#19
module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#25
  def compile_if_an_interpolation(string); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#37
  def interpolated_str?(str); end

  protected

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#58
  def compile_interpolation_token(key); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#47
  def compiled_interpolation_body(str); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#71
  def direct_key(key); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#91
  def escape_key_sym(key); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#87
  def escape_plain_str(str); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#53
  def handle_interpolation_token(interpolation, matchdata); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#67
  def interpolate_key(key); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#62
  def interpolate_or_raise_missing(key); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#79
  def missing_key(key); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#75
  def nil_key(key); end

  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#83
  def reserved_key(key); end

  # tokenize("foo %{bar} baz %%{buz}") # => ["foo ", "%{bar}", " baz ", "%%{buz}"]
  #
  # source://i18n//lib/i18n/backend/interpolation_compiler.rb#43
  def tokenize(str); end
end

# source://i18n//lib/i18n/backend/interpolation_compiler.rb#23
I18n::Backend::InterpolationCompiler::Compiler::INTERPOLATION_SYNTAX_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://i18n//lib/i18n/backend/interpolation_compiler.rb#22
I18n::Backend::InterpolationCompiler::Compiler::TOKENIZER = T.let(T.unsafe(nil), Regexp)

# This is a basic backend for key value stores. It receives on
# initialization the store, which should respond to three methods:
#
# * store#[](key)         - Used to get a value
# * store#[]=(key, value) - Used to set a value
# * store#keys            - Used to get all keys
#
# Since these stores only supports string, all values are converted
# to JSON before being stored, allowing it to also store booleans,
# hashes and arrays. However, this store does not support Procs.
#
# As the ActiveRecord backend, Symbols are just supported when loading
# translations from the filesystem or through explicit store translations.
#
# Also, avoid calling I18n.available_locales since it's a somehow
# expensive operation in most stores.
#
# == Example
#
# To setup I18n to use TokyoCabinet in memory is quite straightforward:
#
#   require 'rufus/tokyo/cabinet' # gem install rufus-tokyo
#   I18n.backend = I18n::Backend::KeyValue.new(Rufus::Tokyo::Cabinet.new('*'))
#
# == Performance
#
# You may make this backend even faster by including the Memoize module.
# However, notice that you should properly clear the cache if you change
# values directly in the key-store.
#
# == Subtrees
#
# In most backends, you are allowed to retrieve part of a translation tree:
#
#   I18n.backend.store_translations :en, :foo => { :bar => :baz }
#   I18n.t "foo" #=> { :bar => :baz }
#
# This backend supports this feature by default, but it slows down the storage
# of new data considerably and makes hard to delete entries. That said, you are
# allowed to disable the storage of subtrees on initialization:
#
#   I18n::Backend::KeyValue.new(@store, false)
#
# This is useful if you are using a KeyValue backend chained to a Simple backend.
#
# source://i18n//lib/i18n/backend/key_value.rb#67
class I18n::Backend::KeyValue
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base
  include ::I18n::Backend::KeyValue::Implementation
end

# source://i18n//lib/i18n/backend/key_value.rb#68
module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base

  # source://i18n//lib/i18n/backend/key_value.rb#73
  def initialize(store, subtrees = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/key_value.rb#96
  def available_locales; end

  # Returns the value of attribute store.
  #
  # source://i18n//lib/i18n/backend/key_value.rb#69
  def store; end

  # Sets the attribute store
  #
  # @param value the value to set the attribute store to.
  #
  # source://i18n//lib/i18n/backend/key_value.rb#69
  def store=(_arg0); end

  # source://i18n//lib/i18n/backend/key_value.rb#77
  def store_translations(locale, data, options = T.unsafe(nil)); end

  protected

  # source://i18n//lib/i18n/backend/key_value.rb#110
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/key_value.rb#124
  def pluralize(locale, entry, count); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/key_value.rb#106
  def subtrees?; end
end

# source://i18n//lib/i18n/backend/key_value.rb#134
class I18n::Backend::KeyValue::SubtreeProxy
  # @return [SubtreeProxy] a new instance of SubtreeProxy
  #
  # source://i18n//lib/i18n/backend/key_value.rb#135
  def initialize(master_key, store); end

  # source://i18n//lib/i18n/backend/key_value.rb#145
  def [](key); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/key_value.rb#141
  def has_key?(key); end

  # source://i18n//lib/i18n/backend/key_value.rb#169
  def inspect; end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/key_value.rb#161
  def instance_of?(klass); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/key_value.rb#156
  def is_a?(klass); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/key_value.rb#156
  def kind_of?(klass); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/key_value.rb#165
  def nil?; end
end

# source://i18n//lib/i18n/backend/memoize.rb#12
module I18n::Backend::Memoize
  # source://i18n//lib/i18n/backend/memoize.rb#13
  def available_locales; end

  # source://i18n//lib/i18n/backend/memoize.rb#22
  def reload!; end

  # source://i18n//lib/i18n/backend/memoize.rb#17
  def store_translations(locale, data, options = T.unsafe(nil)); end

  protected

  # source://i18n//lib/i18n/backend/memoize.rb#29
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/memoize.rb#36
  def memoized_lookup; end

  # source://i18n//lib/i18n/backend/memoize.rb#40
  def reset_memoizations!(locale = T.unsafe(nil)); end
end

# source://i18n//lib/i18n/backend/metadata.rb#19
module I18n::Backend::Metadata
  # source://i18n//lib/i18n/backend/metadata.rb#50
  def interpolate(locale, entry, values = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/metadata.rb#55
  def pluralize(locale, entry, count); end

  # source://i18n//lib/i18n/backend/metadata.rb#38
  def translate(locale, key, options = T.unsafe(nil)); end

  protected

  # source://i18n//lib/i18n/backend/metadata.rb#61
  def with_metadata(metadata, &block); end

  class << self
    # @private
    #
    # source://i18n//lib/i18n/backend/metadata.rb#21
    def included(base); end
  end
end

# source://i18n//lib/i18n/backend/pluralization.rb#14
module I18n::Backend::Pluralization
  # Overwrites the Base backend translate method so that it will check the
  # translation meta data space (:i18n) for a locale specific pluralization
  # rule and use it to pluralize the given entry. I.e. the library expects
  # pluralization rules to be stored at I18n.t(:'i18n.plural.rule')
  #
  # Pluralization rules are expected to respond to #call(count) and
  # return a pluralization key. Valid keys depend on the translation data
  # hash (entry) but it is generally recommended to follow CLDR's style,
  # i.e., return one of the keys :zero, :one, :few, :many, :other.
  #
  # The :zero key is always picked directly when count equals 0 AND the
  # translation data has the key :zero. This way translators are free to
  # either pick a special :zero translation even for languages where the
  # pluralizer does not return a :zero key.
  #
  # source://i18n//lib/i18n/backend/pluralization.rb#29
  def pluralize(locale, entry, count); end

  protected

  # source://i18n//lib/i18n/backend/pluralization.rb#48
  def pluralizer(locale); end

  # source://i18n//lib/i18n/backend/pluralization.rb#44
  def pluralizers; end
end

# A simple backend that reads translations from YAML files and stores them in
# an in-memory hash. Relies on the Base backend.
#
# The implementation is provided by a Implementation module allowing to easily
# extend Simple backend's behavior by including modules. E.g.:
#
# module I18n::Backend::Pluralization
#   def pluralize(*args)
#     # extended pluralization logic
#     super
#   end
# end
#
# I18n::Backend::Simple.include(I18n::Backend::Pluralization)
#
# source://i18n//lib/i18n/backend/simple.rb#17
class I18n::Backend::Simple
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base
  include ::I18n::Backend::Simple::Implementation
end

# source://i18n//lib/i18n/backend/simple.rb#20
module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base

  # Get available locales from the translations hash
  #
  # source://i18n//lib/i18n/backend/simple.rb#45
  def available_locales; end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n/backend/simple.rb#23
  def initialized?; end

  # Clean up translations hash and set initialized to false on reload!
  #
  # source://i18n//lib/i18n/backend/simple.rb#54
  def reload!; end

  # Stores translations for the given locale in memory.
  # This uses a deep merge for the translations hash, so existing
  # translations will be overwritten by new ones only at the deepest
  # level of the hash.
  #
  # source://i18n//lib/i18n/backend/simple.rb#31
  def store_translations(locale, data, options = T.unsafe(nil)); end

  protected

  # source://i18n//lib/i18n/backend/simple.rb#62
  def init_translations; end

  # Looks up a translation from the translations hash. Returns nil if
  # either key is nil, or locale, scope or key do not exist as a key in the
  # nested translations hash. Splits keys or scopes containing dots
  # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
  # <tt>%w(currency format)</tt>.
  #
  # source://i18n//lib/i18n/backend/simple.rb#76
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/simple.rb#67
  def translations; end
end

# source://i18n//lib/i18n/backend/transliterator.rb#4
module I18n::Backend::Transliterator
  # Given a locale and a UTF-8 string, return the locale's ASCII
  # approximation for the string.
  #
  # source://i18n//lib/i18n/backend/transliterator.rb#9
  def transliterate(locale, string, replacement = T.unsafe(nil)); end

  class << self
    # Get a transliterator instance.
    #
    # source://i18n//lib/i18n/backend/transliterator.rb#17
    def get(rule = T.unsafe(nil)); end
  end
end

# source://i18n//lib/i18n/backend/transliterator.rb#5
I18n::Backend::Transliterator::DEFAULT_REPLACEMENT_CHAR = T.let(T.unsafe(nil), String)

# A transliterator which accepts a Hash of characters as its translation
# rule.
#
# source://i18n//lib/i18n/backend/transliterator.rb#40
class I18n::Backend::Transliterator::HashTransliterator
  # @return [HashTransliterator] a new instance of HashTransliterator
  #
  # source://i18n//lib/i18n/backend/transliterator.rb#72
  def initialize(rule = T.unsafe(nil)); end

  # source://i18n//lib/i18n/backend/transliterator.rb#78
  def transliterate(string, replacement = T.unsafe(nil)); end

  private

  # Add transliteration rules to the approximations hash.
  #
  # source://i18n//lib/i18n/backend/transliterator.rb#98
  def add(hash); end

  # source://i18n//lib/i18n/backend/transliterator.rb#91
  def add_default_approximations; end

  # source://i18n//lib/i18n/backend/transliterator.rb#87
  def approximations; end
end

# source://i18n//lib/i18n/backend/transliterator.rb#41
I18n::Backend::Transliterator::HashTransliterator::DEFAULT_APPROXIMATIONS = T.let(T.unsafe(nil), Hash)

# A transliterator which accepts a Proc as its transliteration rule.
#
# source://i18n//lib/i18n/backend/transliterator.rb#28
class I18n::Backend::Transliterator::ProcTransliterator
  # @return [ProcTransliterator] a new instance of ProcTransliterator
  #
  # source://i18n//lib/i18n/backend/transliterator.rb#29
  def initialize(rule); end

  # source://i18n//lib/i18n/backend/transliterator.rb#33
  def transliterate(string, replacement = T.unsafe(nil)); end
end

# source://i18n//lib/i18n.rb#23
module I18n::Base
  # source://i18n//lib/i18n.rb#38
  def available_locales; end

  # source://i18n//lib/i18n.rb#42
  def available_locales=(value); end

  # @return [Boolean]
  #
  # source://i18n//lib/i18n.rb#299
  def available_locales_initialized?; end

  # source://i18n//lib/i18n.rb#38
  def backend; end

  # source://i18n//lib/i18n.rb#42
  def backend=(value); end

  # Gets I18n configuration object.
  #
  # source://i18n//lib/i18n.rb#25
  def config; end

  # Sets I18n configuration object.
  #
  # source://i18n//lib/i18n.rb#30
  def config=(value); end

  # source://i18n//lib/i18n.rb#38
  def default_locale; end

  # source://i18n//lib/i18n.rb#42
  def default_locale=(value); end

  # source://i18n//lib/i18n.rb#38
  def default_separator; end

  # source://i18n//lib/i18n.rb#42
  def default_separator=(value); end

  # source://i18n//lib/i18n.rb#38
  def enforce_available_locales; end

  # Raises an InvalidLocale exception when the passed locale is not available.
  #
  # source://i18n//lib/i18n.rb#293
  def enforce_available_locales!(locale); end

  # source://i18n//lib/i18n.rb#42
  def enforce_available_locales=(value); end

  # source://i18n//lib/i18n.rb#38
  def exception_handler; end

  # source://i18n//lib/i18n.rb#42
  def exception_handler=(value); end

  # Returns true if a translation exists for a given key, otherwise returns false.
  #
  # @raise [I18n::ArgumentError]
  # @return [Boolean]
  #
  # source://i18n//lib/i18n.rb#184
  def exists?(key, locale = T.unsafe(nil)); end

  # Localizes certain objects, such as dates and numbers to local formatting.
  #
  # source://i18n//lib/i18n.rb#253
  def l(object, options = T.unsafe(nil)); end

  # source://i18n//lib/i18n.rb#38
  def load_path; end

  # source://i18n//lib/i18n.rb#42
  def load_path=(value); end

  # source://i18n//lib/i18n.rb#38
  def locale; end

  # source://i18n//lib/i18n.rb#42
  def locale=(value); end

  # Returns true when the passed locale, which can be either a String or a
  # Symbol, is in the list of available locales. Returns false otherwise.
  #
  # @return [Boolean]
  #
  # source://i18n//lib/i18n.rb#288
  def locale_available?(locale); end

  # Localizes certain objects, such as dates and numbers to local formatting.
  #
  # source://i18n//lib/i18n.rb#253
  def localize(object, options = T.unsafe(nil)); end

  # Merges the given locale, key and scope into a single array of keys.
  # Splits keys that contain dots into multiple keys. Makes sure all
  # keys are Symbols.
  #
  # source://i18n//lib/i18n.rb#276
  def normalize_keys(locale, key, scope, separator = T.unsafe(nil)); end

  # Tells the backend to reload translations. Used in situations like the
  # Rails development environment. Backends can implement whatever strategy
  # is useful.
  #
  # source://i18n//lib/i18n.rb#51
  def reload!; end

  # Translates, pluralizes and interpolates a given key using a given locale,
  # scope, and default, as well as interpolation values.
  #
  # *LOOKUP*
  #
  # Translation data is organized as a nested hash using the upper-level keys
  # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
  # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
  #
  # Translations can be looked up at any level of this hash using the key argument
  # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
  # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
  #
  # Key can be either a single key or a dot-separated key (both Strings and Symbols
  # work). <em>E.g.</em>, the short format can be looked up using both:
  #   I18n.t 'date.formats.short'
  #   I18n.t :'date.formats.short'
  #
  # Scope can be either a single key, a dot-separated key or an array of keys
  # or dot-separated keys. Keys and scopes can be combined freely. So these
  # examples will all look up the same short date format:
  #   I18n.t 'date.formats.short'
  #   I18n.t 'formats.short', :scope => 'date'
  #   I18n.t 'short', :scope => 'date.formats'
  #   I18n.t 'short', :scope => %w(date formats)
  #
  # *INTERPOLATION*
  #
  # Translations can contain interpolation variables which will be replaced by
  # values passed to #translate as part of the options hash, with the keys matching
  # the interpolation variable names.
  #
  # <em>E.g.</em>, with a translation <tt>:foo => "foo %{bar}"</tt> the option
  # value for the key +bar+ will be interpolated into the translation:
  #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
  #
  # *PLURALIZATION*
  #
  # Translation data can contain pluralized translations. Pluralized translations
  # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
  #
  # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
  # pluralization rules. Other algorithms can be supported by custom backends.
  #
  # This returns the singular version of a pluralized translation:
  #   I18n.t :foo, :count => 1 # => 'Foo'
  #
  # These both return the plural version of a pluralized translation:
  #   I18n.t :foo, :count => 0 # => 'Foos'
  #   I18n.t :foo, :count => 2 # => 'Foos'
  #
  # The <tt>:count</tt> option can be used both for pluralization and interpolation.
  # <em>E.g.</em>, with the translation
  # <tt>:foo => ['%{count} foo', '%{count} foos']</tt>, count will
  # be interpolated to the pluralized translation:
  #   I18n.t :foo, :count => 1 # => '1 foo'
  #
  # *DEFAULTS*
  #
  # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
  #   I18n.t :foo, :default => 'default'
  #
  # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
  # translation for <tt>:foo</tt> was found:
  #   I18n.t :foo, :default => :bar
  #
  # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
  # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
  #   I18n.t :foo, :default => [:bar, 'default']
  #
  # *BULK LOOKUP*
  #
  # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
  #   I18n.t [:foo, :bar]
  #
  # Can be used with dot-separated nested keys:
  #   I18n.t [:'baz.foo', :'baz.bar']
  #
  # Which is the same as using a scope option:
  #   I18n.t [:foo, :bar], :scope => :baz
  #
  # *LAMBDAS*
  #
  # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
  # called and passed the key and options.
  #
  # E.g. assuming the key <tt>:salutation</tt> resolves to:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. #{options[:name]}" : "Mrs. #{options[:name]}" }
  #
  # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
  #
  # Note that the string returned by lambda will go through string interpolation too,
  # so the following lambda would give the same result:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. %{name}" : "Mrs. %{name}" }
  #
  # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
  # a cache layer is put in front of I18n.translate it will generate a cache key
  # from the argument values passed to #translate. Therefor your lambdas should
  # always return the same translations/values per unique combination of argument
  # values.
  #
  # source://i18n//lib/i18n.rb#156
  def t(*args); end

  # Wrapper for <tt>translate</tt> that adds <tt>:raise => true</tt>. With
  # this option, if no translation is found, it will raise <tt>I18n::MissingTranslationData</tt>
  #
  # source://i18n//lib/i18n.rb#178
  def t!(key, options = T.unsafe(nil)); end

  # Translates, pluralizes and interpolates a given key using a given locale,
  # scope, and default, as well as interpolation values.
  #
  # *LOOKUP*
  #
  # Translation data is organized as a nested hash using the upper-level keys
  # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
  # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
  #
  # Translations can be looked up at any level of this hash using the key argument
  # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
  # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
  #
  # Key can be either a single key or a dot-separated key (both Strings and Symbols
  # work). <em>E.g.</em>, the short format can be looked up using both:
  #   I18n.t 'date.formats.short'
  #   I18n.t :'date.formats.short'
  #
  # Scope can be either a single key, a dot-separated key or an array of keys
  # or dot-separated keys. Keys and scopes can be combined freely. So these
  # examples will all look up the same short date format:
  #   I18n.t 'date.formats.short'
  #   I18n.t 'formats.short', :scope => 'date'
  #   I18n.t 'short', :scope => 'date.formats'
  #   I18n.t 'short', :scope => %w(date formats)
  #
  # *INTERPOLATION*
  #
  # Translations can contain interpolation variables which will be replaced by
  # values passed to #translate as part of the options hash, with the keys matching
  # the interpolation variable names.
  #
  # <em>E.g.</em>, with a translation <tt>:foo => "foo %{bar}"</tt> the option
  # value for the key +bar+ will be interpolated into the translation:
  #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
  #
  # *PLURALIZATION*
  #
  # Translation data can contain pluralized translations. Pluralized translations
  # are arrays of singluar/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
  #
  # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
  # pluralization rules. Other algorithms can be supported by custom backends.
  #
  # This returns the singular version of a pluralized translation:
  #   I18n.t :foo, :count => 1 # => 'Foo'
  #
  # These both return the plural version of a pluralized translation:
  #   I18n.t :foo, :count => 0 # => 'Foos'
  #   I18n.t :foo, :count => 2 # => 'Foos'
  #
  # The <tt>:count</tt> option can be used both for pluralization and interpolation.
  # <em>E.g.</em>, with the translation
  # <tt>:foo => ['%{count} foo', '%{count} foos']</tt>, count will
  # be interpolated to the pluralized translation:
  #   I18n.t :foo, :count => 1 # => '1 foo'
  #
  # *DEFAULTS*
  #
  # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
  #   I18n.t :foo, :default => 'default'
  #
  # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
  # translation for <tt>:foo</tt> was found:
  #   I18n.t :foo, :default => :bar
  #
  # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
  # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
  #   I18n.t :foo, :default => [:bar, 'default']
  #
  # *BULK LOOKUP*
  #
  # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
  #   I18n.t [:foo, :bar]
  #
  # Can be used with dot-separated nested keys:
  #   I18n.t [:'baz.foo', :'baz.bar']
  #
  # Which is the same as using a scope option:
  #   I18n.t [:foo, :bar], :scope => :baz
  #
  # *LAMBDAS*
  #
  # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
  # called and passed the key and options.
  #
  # E.g. assuming the key <tt>:salutation</tt> resolves to:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. #{options[:name]}" : "Mrs. #{options[:name]}" }
  #
  # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
  #
  # Note that the string returned by lambda will go through string interpolation too,
  # so the following lambda would give the same result:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. %{name}" : "Mrs. %{name}" }
  #
  # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
  # a cache layer is put in front of I18n.translate it will generate a cache key
  # from the argument values passed to #translate. Therefor your lambdas should
  # always return the same translations/values per unique combination of argument
  # values.
  #
  # source://i18n//lib/i18n.rb#156
  def translate(*args); end

  # Wrapper for <tt>translate</tt> that adds <tt>:raise => true</tt>. With
  # this option, if no translation is found, it will raise <tt>I18n::MissingTranslationData</tt>
  #
  # source://i18n//lib/i18n.rb#178
  def translate!(key, options = T.unsafe(nil)); end

  # Transliterates UTF-8 characters to ASCII. By default this method will
  # transliterate only Latin strings to an ASCII approximation:
  #
  #    I18n.transliterate("Ærøskøbing")
  #    # => "AEroskobing"
  #
  #    I18n.transliterate("日本語")
  #    # => "???"
  #
  # It's also possible to add support for per-locale transliterations. I18n
  # expects transliteration rules to be stored at
  # <tt>i18n.transliterate.rule</tt>.
  #
  # Transliteration rules can either be a Hash or a Proc. Procs must accept a
  # single string argument. Hash rules inherit the default transliteration
  # rules, while Procs do not.
  #
  # *Examples*
  #
  # Setting a Hash in <locale>.yml:
  #
  #    i18n:
  #      transliterate:
  #        rule:
  #          ü: "ue"
  #          ö: "oe"
  #
  # Setting a Hash using Ruby:
  #
  #     store_translations(:de, :i18n => {
  #       :transliterate => {
  #         :rule => {
  #           "ü" => "ue",
  #           "ö" => "oe"
  #         }
  #       }
  #     )
  #
  # Setting a Proc:
  #
  #     translit = lambda {|string| MyTransliterator.transliterate(string) }
  #     store_translations(:xx, :i18n => {:transliterate => {:rule => translit})
  #
  # Transliterating strings:
  #
  #     I18n.locale = :en
  #     I18n.transliterate("Jürgen") # => "Jurgen"
  #     I18n.locale = :de
  #     I18n.transliterate("Jürgen") # => "Juergen"
  #     I18n.transliterate("Jürgen", :locale => :en) # => "Jurgen"
  #     I18n.transliterate("Jürgen", :locale => :de) # => "Juergen"
  #
  # source://i18n//lib/i18n.rb#240
  def transliterate(*args); end

  # Executes block with given I18n.locale set.
  #
  # source://i18n//lib/i18n.rb#263
  def with_locale(tmp_locale = T.unsafe(nil)); end

  private

  # Any exceptions thrown in translate will be sent to the @@exception_handler
  # which can be a Symbol, a Proc or any other Object unless they're forced to
  # be raised or thrown (MissingTranslation).
  #
  # If exception_handler is a Symbol then it will simply be sent to I18n as
  # a method call. A Proc will simply be called. In any other case the
  # method #call will be called on the exception_handler object.
  #
  # Examples:
  #
  #   I18n.exception_handler = :custom_exception_handler              # this is the default
  #   I18n.custom_exception_handler(exception, locale, key, options)  # will be called like this
  #
  #   I18n.exception_handler = lambda { |*args| ... }                 # a lambda
  #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
  #
  #   I18n.exception_handler = I18nExceptionHandler.new               # an object
  #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
  #
  # source://i18n//lib/i18n.rb#323
  def handle_exception(handling, exception, locale, key, options); end

  # source://i18n//lib/i18n.rb#341
  def normalize_key(key, separator); end
end

# source://i18n//lib/i18n/config.rb#4
class I18n::Config
  # Returns an array of locales for which translations are available.
  # Unless you explicitely set these through I18n.available_locales=
  # the call will be delegated to the backend.
  #
  # source://i18n//lib/i18n/config.rb#41
  def available_locales; end

  # Sets the available locales.
  #
  # source://i18n//lib/i18n/config.rb#55
  def available_locales=(locales); end

  # Returns true if the available_locales have been initialized
  #
  # @return [Boolean]
  #
  # source://i18n//lib/i18n/config.rb#62
  def available_locales_initialized?; end

  # Caches the available locales list as both strings and symbols in a Set, so
  # that we can have faster lookups to do the available locales enforce check.
  #
  # source://i18n//lib/i18n/config.rb#48
  def available_locales_set; end

  # Returns the current backend. Defaults to +Backend::Simple+.
  #
  # source://i18n//lib/i18n/config.rb#18
  def backend; end

  # Sets the current backend. Used to set a custom backend.
  #
  # source://i18n//lib/i18n/config.rb#23
  def backend=(backend); end

  # Clears the available locales set so it can be recomputed again after I18n
  # gets reloaded.
  #
  # source://i18n//lib/i18n/config.rb#68
  def clear_available_locales_set; end

  # Returns the current default locale. Defaults to :'en'
  #
  # source://i18n//lib/i18n/config.rb#28
  def default_locale; end

  # Sets the current default locale. Used to set a custom default locale.
  #
  # source://i18n//lib/i18n/config.rb#33
  def default_locale=(locale); end

  # Returns the current default scope separator. Defaults to '.'
  #
  # source://i18n//lib/i18n/config.rb#73
  def default_separator; end

  # Sets the current default scope separator.
  #
  # source://i18n//lib/i18n/config.rb#78
  def default_separator=(separator); end

  # source://i18n//lib/i18n/config.rb#139
  def enforce_available_locales; end

  # source://i18n//lib/i18n/config.rb#143
  def enforce_available_locales=(enforce_available_locales); end

  # Returns the current exception handler. Defaults to an instance of
  # I18n::ExceptionHandler.
  #
  # source://i18n//lib/i18n/config.rb#84
  def exception_handler; end

  # Sets the exception handler.
  #
  # source://i18n//lib/i18n/config.rb#89
  def exception_handler=(exception_handler); end

  # Allow clients to register paths providing translation data sources. The
  # backend defines acceptable sources.
  #
  # E.g. the provided SimpleBackend accepts a list of paths to translation
  # files which are either named *.rb and contain plain Ruby Hashes or are
  # named *.yml and contain YAML data. So for the SimpleBackend clients may
  # register translation files like this:
  #   I18n.load_path << 'path/to/locale/en.yml'
  #
  # source://i18n//lib/i18n/config.rb#124
  def load_path; end

  # Sets the load path instance. Custom implementations are expected to
  # behave like a Ruby Array.
  #
  # source://i18n//lib/i18n/config.rb#130
  def load_path=(load_path); end

  # The only configuration value that is not global and scoped to thread is :locale.
  # It defaults to the default_locale.
  #
  # source://i18n//lib/i18n/config.rb#7
  def locale; end

  # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
  #
  # source://i18n//lib/i18n/config.rb#12
  def locale=(locale); end

  # Returns the current handler for situations when interpolation argument
  # is missing. MissingInterpolationArgument will be raised by default.
  #
  # source://i18n//lib/i18n/config.rb#95
  def missing_interpolation_argument_handler; end

  # Sets the missing interpolation argument handler. It can be any
  # object that responds to #call. The arguments that will be passed to #call
  # are the same as for MissingInterpolationArgument initializer. Use +Proc.new+
  # if you don't care about arity.
  #
  # == Example:
  # You can supress raising an exception and return string instead:
  #
  #   I18n.config.missing_interpolation_argument_handler = Proc.new do |key|
  #     "#{key} is missing"
  #   end
  #
  # source://i18n//lib/i18n/config.rb#112
  def missing_interpolation_argument_handler=(exception_handler); end
end

# Handles exceptions raised in the backend. All exceptions except for
# MissingTranslationData exceptions are re-thrown. When a MissingTranslationData
# was caught the handler returns an error message string containing the key/scope.
# Note that the exception handler is not called when the option :throw was given.
#
# source://i18n//lib/i18n/exceptions.rb#8
class I18n::ExceptionHandler; end

# source://i18n//lib/i18n/gettext.rb#2
module I18n::Gettext
  class << self
    # source://i18n//lib/i18n/gettext.rb#19
    def extract_scope(msgid, separator); end

    # returns an array of plural keys for the given locale or the whole hash
    # of locale mappings to plural keys so that we can convert from gettext's
    # integer-index based style
    # TODO move this information to the pluralization module
    #
    # source://i18n//lib/i18n/gettext.rb#15
    def plural_keys(*args); end
  end
end

# source://i18n//lib/i18n/gettext.rb#4
I18n::Gettext::CONTEXT_SEPARATOR = T.let(T.unsafe(nil), String)

# Implements classical Gettext style accessors. To use this include the
# module to the global namespace or wherever you want to use it.
#
#   include I18n::Gettext::Helpers
#
# source://i18n//lib/i18n/gettext/helpers.rb#9
module I18n::Gettext::Helpers
  # Makes dynamic translation messages readable for the gettext parser.
  # <tt>_(fruit)</tt> cannot be understood by the gettext parser. To help the parser find all your translations,
  # you can add <tt>fruit = N_("Apple")</tt> which does not translate, but tells the parser: "Apple" needs translation.
  # * msgid: the message id.
  # * Returns: msgid.
  #
  # source://i18n//lib/i18n/gettext/helpers.rb#15
  def N_(msgsid); end

  # source://i18n//lib/i18n/gettext/helpers.rb#19
  def _(msgid, options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/gettext/helpers.rb#19
  def gettext(msgid, options = T.unsafe(nil)); end

  # source://i18n//lib/i18n/gettext/helpers.rb#36
  def n_(msgid, msgid_plural, n = T.unsafe(nil)); end

  # source://i18n//lib/i18n/gettext/helpers.rb#36
  def ngettext(msgid, msgid_plural, n = T.unsafe(nil)); end

  # Method signatures:
  #   npgettext('Fruits', 'apple', 'apples', 2)
  #   npgettext('Fruits', ['apple', 'apples'], 2)
  #
  # source://i18n//lib/i18n/gettext/helpers.rb#59
  def np_(msgctxt, msgid, msgid_plural, n = T.unsafe(nil)); end

  # Method signatures:
  #   npgettext('Fruits', 'apple', 'apples', 2)
  #   npgettext('Fruits', ['apple', 'apples'], 2)
  #
  # source://i18n//lib/i18n/gettext/helpers.rb#59
  def npgettext(msgctxt, msgid, msgid_plural, n = T.unsafe(nil)); end

  # Method signatures:
  #   nsgettext('Fruits|apple', 'apples', 2)
  #   nsgettext(['Fruits|apple', 'apples'], 2)
  #
  # source://i18n//lib/i18n/gettext/helpers.rb#44
  def ns_(msgid, msgid_plural, n = T.unsafe(nil), separator = T.unsafe(nil)); end

  # Method signatures:
  #   nsgettext('Fruits|apple', 'apples', 2)
  #   nsgettext(['Fruits|apple', 'apples'], 2)
  #
  # source://i18n//lib/i18n/gettext/helpers.rb#44
  def nsgettext(msgid, msgid_plural, n = T.unsafe(nil), separator = T.unsafe(nil)); end

  # source://i18n//lib/i18n/gettext/helpers.rb#30
  def p_(msgctxt, msgid); end

  # source://i18n//lib/i18n/gettext/helpers.rb#30
  def pgettext(msgctxt, msgid); end

  # source://i18n//lib/i18n/gettext/helpers.rb#24
  def s_(msgid, separator = T.unsafe(nil)); end

  # source://i18n//lib/i18n/gettext/helpers.rb#24
  def sgettext(msgid, separator = T.unsafe(nil)); end
end

# source://i18n//lib/i18n/gettext.rb#3
I18n::Gettext::PLURAL_SEPARATOR = T.let(T.unsafe(nil), String)

# source://i18n//lib/i18n/interpolate/ruby.rb#5
I18n::INTERPOLATION_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://i18n//lib/i18n/exceptions.rb#25
class I18n::InvalidLocale < ::I18n::ArgumentError
  # @return [InvalidLocale] a new instance of InvalidLocale
  #
  # source://i18n//lib/i18n/exceptions.rb#27
  def initialize(locale); end

  # Returns the value of attribute locale.
  #
  # source://i18n//lib/i18n/exceptions.rb#26
  def locale; end
end

# source://i18n//lib/i18n/exceptions.rb#33
class I18n::InvalidLocaleData < ::I18n::ArgumentError
  # @return [InvalidLocaleData] a new instance of InvalidLocaleData
  #
  # source://i18n//lib/i18n/exceptions.rb#35
  def initialize(filename, exception_message); end

  # Returns the value of attribute filename.
  #
  # source://i18n//lib/i18n/exceptions.rb#34
  def filename; end
end

# source://i18n//lib/i18n/exceptions.rb#73
class I18n::InvalidPluralizationData < ::I18n::ArgumentError
  # @return [InvalidPluralizationData] a new instance of InvalidPluralizationData
  #
  # source://i18n//lib/i18n/exceptions.rb#75
  def initialize(entry, count, key); end

  # Returns the value of attribute count.
  #
  # source://i18n//lib/i18n/exceptions.rb#74
  def count; end

  # Returns the value of attribute entry.
  #
  # source://i18n//lib/i18n/exceptions.rb#74
  def entry; end

  # Returns the value of attribute key.
  #
  # source://i18n//lib/i18n/exceptions.rb#74
  def key; end
end

# source://i18n//lib/i18n/backend/key_value.rb#19
I18n::JSON = ActiveSupport::JSON

# source://i18n//lib/i18n/locale.rb#2
module I18n::Locale; end

# source://i18n//lib/i18n/locale/fallbacks.rb#55
class I18n::Locale::Fallbacks < ::Hash
  # @return [Fallbacks] a new instance of Fallbacks
  #
  # source://i18n//lib/i18n/locale/fallbacks.rb#56
  def initialize(*mappings); end

  # @raise [InvalidLocale]
  #
  # source://i18n//lib/i18n/locale/fallbacks.rb#67
  def [](locale); end

  # Returns the value of attribute defaults.
  #
  # source://i18n//lib/i18n/locale/fallbacks.rb#65
  def defaults; end

  # source://i18n//lib/i18n/locale/fallbacks.rb#62
  def defaults=(defaults); end

  # source://i18n//lib/i18n/locale/fallbacks.rb#73
  def map(mappings); end

  protected

  # source://i18n//lib/i18n/locale/fallbacks.rb#85
  def compute(tags, include_defaults = T.unsafe(nil), exclude = T.unsafe(nil)); end
end

# source://i18n//lib/i18n/locale/tag.rb#5
module I18n::Locale::Tag
  class << self
    # Returns the current locale tag implementation. Defaults to +I18n::Locale::Tag::Simple+.
    #
    # source://i18n//lib/i18n/locale/tag.rb#12
    def implementation; end

    # Sets the current locale tag implementation. Use this to set a different locale tag implementation.
    #
    # source://i18n//lib/i18n/locale/tag.rb#17
    def implementation=(implementation); end

    # Factory method for locale tags. Delegates to the current locale tag implementation.
    #
    # source://i18n//lib/i18n/locale/tag.rb#22
    def tag(tag); end
  end
end

# source://i18n//lib/i18n/locale/tag/parents.rb#4
module I18n::Locale::Tag::Parents
  # source://i18n//lib/i18n/locale/tag/parents.rb#5
  def parent; end

  # source://i18n//lib/i18n/locale/tag/parents.rb#16
  def parents; end

  # source://i18n//lib/i18n/locale/tag/parents.rb#12
  def self_and_parents; end
end

# source://i18n//lib/i18n/locale/tag/rfc4646.rb#12
I18n::Locale::Tag::RFC4646_FORMATS = T.let(T.unsafe(nil), Hash)

# source://i18n//lib/i18n/locale/tag/rfc4646.rb#11
I18n::Locale::Tag::RFC4646_SUBTAGS = T.let(T.unsafe(nil), Array)

# source://i18n//lib/i18n/locale/tag/rfc4646.rb#14
class I18n::Locale::Tag::Rfc4646 < ::Struct
  include ::I18n::Locale::Tag::Parents

  # source://i18n//lib/i18n/locale/tag/rfc4646.rb#35
  def language; end

  # source://i18n//lib/i18n/locale/tag/rfc4646.rb#35
  def region; end

  # source://i18n//lib/i18n/locale/tag/rfc4646.rb#35
  def script; end

  # source://i18n//lib/i18n/locale/tag/rfc4646.rb#46
  def to_a; end

  # source://i18n//lib/i18n/locale/tag/rfc4646.rb#42
  def to_s; end

  # source://i18n//lib/i18n/locale/tag/rfc4646.rb#38
  def to_sym; end

  # source://i18n//lib/i18n/locale/tag/rfc4646.rb#35
  def variant; end

  class << self
    # source://i18n//lib/i18n/locale/tag/rfc4646.rb#23
    def parser; end

    # source://i18n//lib/i18n/locale/tag/rfc4646.rb#27
    def parser=(parser); end

    # Parses the given tag and returns a Tag instance if it is valid.
    # Returns false if the given tag is not valid according to RFC 4646.
    #
    # source://i18n//lib/i18n/locale/tag/rfc4646.rb#18
    def tag(tag); end
  end
end

# source://i18n//lib/i18n/locale/tag/rfc4646.rb#50
module I18n::Locale::Tag::Rfc4646::Parser
  class << self
    # source://i18n//lib/i18n/locale/tag/rfc4646.rb#63
    def match(tag); end
  end
end

# source://i18n//lib/i18n/locale/tag/rfc4646.rb#51
I18n::Locale::Tag::Rfc4646::Parser::PATTERN = T.let(T.unsafe(nil), Regexp)

# source://i18n//lib/i18n/locale/tag/simple.rb#6
class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents

  # @return [Simple] a new instance of Simple
  #
  # source://i18n//lib/i18n/locale/tag/simple.rb#17
  def initialize(*tag); end

  # source://i18n//lib/i18n/locale/tag/simple.rb#21
  def subtags; end

  # Returns the value of attribute tag.
  #
  # source://i18n//lib/i18n/locale/tag/simple.rb#15
  def tag; end

  # source://i18n//lib/i18n/locale/tag/simple.rb#33
  def to_a; end

  # source://i18n//lib/i18n/locale/tag/simple.rb#29
  def to_s; end

  # source://i18n//lib/i18n/locale/tag/simple.rb#25
  def to_sym; end

  class << self
    # source://i18n//lib/i18n/locale/tag/simple.rb#8
    def tag(tag); end
  end
end

# source://i18n//lib/i18n/middleware.rb#2
class I18n::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://i18n//lib/i18n/middleware.rb#4
  def initialize(app); end

  # source://i18n//lib/i18n/middleware.rb#8
  def call(env); end
end

# source://i18n//lib/i18n/exceptions.rb#81
class I18n::MissingInterpolationArgument < ::I18n::ArgumentError
  # @return [MissingInterpolationArgument] a new instance of MissingInterpolationArgument
  #
  # source://i18n//lib/i18n/exceptions.rb#83
  def initialize(key, values, string); end

  # Returns the value of attribute key.
  #
  # source://i18n//lib/i18n/exceptions.rb#82
  def key; end

  # Returns the value of attribute string.
  #
  # source://i18n//lib/i18n/exceptions.rb#82
  def string; end

  # Returns the value of attribute values.
  #
  # source://i18n//lib/i18n/exceptions.rb#82
  def values; end
end

# source://i18n//lib/i18n/exceptions.rb#41
class I18n::MissingTranslation < ::I18n::ArgumentError
  include ::I18n::MissingTranslation::Base
end

# source://i18n//lib/i18n/exceptions.rb#42
module I18n::MissingTranslation::Base
  # source://i18n//lib/i18n/exceptions.rb#45
  def initialize(locale, key, options = T.unsafe(nil)); end

  # Returns the value of attribute key.
  #
  # source://i18n//lib/i18n/exceptions.rb#43
  def key; end

  # source://i18n//lib/i18n/exceptions.rb#50
  def keys; end

  # Returns the value of attribute locale.
  #
  # source://i18n//lib/i18n/exceptions.rb#43
  def locale; end

  # source://i18n//lib/i18n/exceptions.rb#56
  def message; end

  # Returns the value of attribute options.
  #
  # source://i18n//lib/i18n/exceptions.rb#43
  def options; end

  # source://i18n//lib/i18n/exceptions.rb#61
  def to_exception; end

  # source://i18n//lib/i18n/exceptions.rb#56
  def to_s; end
end

# source://i18n//lib/i18n/exceptions.rb#69
class I18n::MissingTranslationData < ::I18n::ArgumentError
  include ::I18n::MissingTranslation::Base
end

# source://i18n//lib/i18n.rb#15
I18n::RESERVED_KEYS = T.let(T.unsafe(nil), Array)

# source://i18n//lib/i18n.rb#16
I18n::RESERVED_KEYS_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://i18n//lib/i18n/exceptions.rb#89
class I18n::ReservedInterpolationKey < ::I18n::ArgumentError
  # @return [ReservedInterpolationKey] a new instance of ReservedInterpolationKey
  #
  # source://i18n//lib/i18n/exceptions.rb#91
  def initialize(key, string); end

  # Returns the value of attribute key.
  #
  # source://i18n//lib/i18n/exceptions.rb#90
  def key; end

  # Returns the value of attribute string.
  #
  # source://i18n//lib/i18n/exceptions.rb#90
  def string; end
end

# source://i18n//lib/i18n/tests.rb#2
module I18n::Tests; end

# source://i18n//lib/i18n/tests/localization.rb#3
module I18n::Tests::Localization
  class << self
    # @private
    #
    # source://i18n//lib/i18n/tests/localization.rb#9
    def included(base); end
  end
end

# source://i18n//lib/i18n/exceptions.rb#97
class I18n::UnknownFileType < ::I18n::ArgumentError
  # @return [UnknownFileType] a new instance of UnknownFileType
  #
  # source://i18n//lib/i18n/exceptions.rb#99
  def initialize(type, filename); end

  # Returns the value of attribute filename.
  #
  # source://i18n//lib/i18n/exceptions.rb#98
  def filename; end

  # Returns the value of attribute type.
  #
  # source://i18n//lib/i18n/exceptions.rb#98
  def type; end
end

# source://i18n//lib/i18n/version.rb#2
I18n::VERSION = T.let(T.unsafe(nil), String)

# source://i18n//lib/i18n/core_ext/kernel/suppress_warnings.rb#1
module Kernel
  # source://i18n//lib/i18n/core_ext/kernel/suppress_warnings.rb#2
  def suppress_warnings; end
end
